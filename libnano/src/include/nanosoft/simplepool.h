#ifndef NANOSOFT_SIMPLEPOOL_H
#define NANOSOFT_SIMPLEPOOL_H

#include <sys/types.h>

namespace nanosoft
{
	/**
	* Простой пул памяти
	*
	* Простой пул памяти для временных объектов.
	* Пул запрашивает у системы кусок памяти необходимого размера.
	* Память выделяется из этого пула снизу вверх.
	*/
	class SimplePool
	{
	private:
		/**
		* Название пула для вывода сообщений об ошибках
		*/
		char *name;
		
		/**
		* Блок данных
		*/
		char *data;
		
		/**
		* Указатель на свободную часть пула
		*/
		char *offset;
		
		/**
		* Указатель на конец пула
		*/
		char *limit;
		
		/**
		* Стек контекстов
		*/
		char **stack;
		
		/**
		* Указатель на вершину стека
		*/
		char **top;
		
		/**
		* Указатель на конец стека
		*/
		char **stackLimit;
		
		/**
		* Максимальный зафиксированный размер занятой памяти
		*/
		size_t peakMemory;
		
		/**
		* Максимальная зафиксированная глубина стека
		*/
		size_t peakDepth;
		
	public:
		/**
		* Конструктор простого пула
		*
		* Параметры size и stack_len определяют размер пула
		* и размер внутреннего стека контекстов. Для нормальной
		* работы пула предполагается, что разработчик или
		* администратор приложения в состоянии оценить требуемые
		* размеры. В случае превышения данных характеристик
		* соответствующие функции выводят в stderr сообщение об
		* ошибке и генерируют исключение.
		*
		* @param name название пула для вывода диагностических сообщений
		* @param size размер пула памяти
		* @param stack_len размер стека контекстов (максимальное число
		*   вложенных контекстов)
		*/
		SimplePool(const char *name, size_t size, size_t stack_len);
		
		/**
		* Деструктор простого пула
		*/
		~SimplePool();
		
		/**
		* Выделить память из пула
		*
		* Если память выделить не удается, то данная функция выводит
		* сообщение об ошибке в stderr и генерирует исключение.
		*
		* @param size требуемый размер блока
		* @return указатель на выделеный блок
		*/
		void * alloc(size_t size);
		
		/**
		* Открыть новый контекст
		*
		* Данная функция запоминает занятый объем, чтобы потом
		* восстановить его методом leave(). Информация сохраняется
		* во внутреннем стеке. Если стек переполнен, то в stderr
		* выводиться сообщение об ошибке и генерируется исключение.
		*/
		void enter();
		
		/**
		* Закрыть контекст
		*
		* Данная функция закрывает контекст и "освобождает"
		* всю память которая была запрошена внутри этого
		* контекста.
		*
		* Если внутренный стек контекстов пуст, то в stderr
		* выводиться сообщение об ошибке и генерируется исключение.
		*/
		void leave();
		
		/**
		* Вернуть название пула
		* @return название пула
		*/
		const char * getPoolName();
		
		/**
		* Вернуть объем свободной памяти
		* @return размер свободной память
		*/
		size_t getFreeSize();
		
		/**
		* Вернуть размер выделенной памяти
		* @return размер выделенной памяти
		*/
		size_t getBusySize();
		
		/**
		* Вернуть глубину контекста
		*/
		size_t getStackDepth();
		
		/**
		* Вернуть максимальный зафиксированный размер занятой памяти
		*
		* Данная функция может использоваться для статистики и эмпирических
		* оценок потребностей в памяти.
		*
		* @return максимальный зафиксированный размер занятой памяти
		*/
		size_t getPeakMemory();
		
		/**
		* Вернуть максимальную зафиксированную глубину стека
		*
		* Данная функция может использоваться для статистики и эмпирической
		* оценки необходимой глубины стека.
		*
		* @return максимальная зафиксированная глубина стека
		*/
		size_t getPeakDepth();
	};
}

#endif // NANOSOFT_SIMPLEPOOL_H
