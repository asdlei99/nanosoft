#ifndef NANOSOFT_BLOCKSPOOL_H
#define NANOSOFT_BLOCKSPOOL_H

#include <stdlib.h>
#include <stdint.h>
#include <nanosoft/config.h>

/**
 * Структура описывающая один блок буфера
 */
struct nano_block_t
{
	/**
	 * Ссылка на блок
	 */
	uint8_t *data;
	
	/**
	 * Ссылка на следующий блок
	 */
	nano_block_t *next;
};

/**
 * Пул блоков памяти
 *
 * Данный класс предоставляет довольно низкоуровневый API и не обеспечивает
 * безопасноти. Пользователь класса должен аккуратно работать с выделенными
 * блоками, недопускать записи информации за пределы блока (т.к. это повредит
 * информацию в других блоках или нарушит целостность всего объекта), не
 * должен пытаться освобождать или перераспределять блоки иным образом,
 * должен возвращать блоки обратно в тот экзепляр пула из котого блоки были
 * выделены.
 *
 * Непосредственная работа пользователя с этим классом не предполагается,
 * он является вспомогательным классом для более высокоуровневых классов
 */
class BlocksPool
{
protected:
	
	/**
	 * Структура описывающая пул (макро-блок)
	 */
	struct pool_t
	{
		/**
		 * Указатель на блок
		 */
		void *data;
		
		/**
		 * Ссылка на следующий пул
		 */
		pool_t *next;
	};
	
	/**
	 * Общее число блоков в пуле
	 */
	int total_count;
	
	/**
	 * Число свободных блоков в пуле
	 */
	int free_count;
	
	/**
	 * Стек свободных блоков
	 */
	nano_block_t *stack;
	
	/**
	 * Пул макро-блоков
	 */
	pool_t *pools;
	
public:
	
	/**
	 * Конструктор
	 */
	BlocksPool();
	
	/**
	 * Деструктор
	 *
	 * Высвобождает все блоки, в том числе те, что выданы клиентам
	 */
	~BlocksPool();
	
	/**
	 * Вернуть общее число блоков
	 */
	int getTotalCount() { return total_count; }
	
	/**
	 * Вернуть число свободных блоков
	 */
	int getFreeCount() { return free_count; }
	
	/**
	 * Зарезервировать блоки
	 *
	 * Запрашивает у системы новые блоки и добавляет их в пул
	 */
	int reserve(size_t count);
	
	/**
	 * Очистить пул
	 *
	 * Высвобождает все блоки, в том числе те, что выданы клиентам
	 */
	void clear();
	
	/**
	 * Выделить цепочку блоков
	 *
	 * @param size требуемый размер в байтах
	 * @return список блоков или NULL если невозможно выделить запрощенный размер
	 */
	nano_block_t* allocBySize(size_t size);
	
	/**
	 * Выделить цепочку блоков
	 *
	 * @param count требуемый размер в блоках
	 * @return список блоков или NULL если невозможно выделить запрощенный размер
	 */
	nano_block_t* allocByBlocks(size_t count);
	
	/**
	 * Освободить цепочку блоков
	 *
	 * NOTE Этот метод не проверяет принадлежат ли ему эти блоки или другому
	 * пулу, просто добавит их в свой пул. Надо быть аккуратным чтобы
	 * возвращать блоки в тот пул из которого они были взяты
	 *
	 * @param list цепочка блоков
	 */
	void free(nano_block_t *list);
	
};

#endif // NANOSOFT_BLOCKSPOOL_H
