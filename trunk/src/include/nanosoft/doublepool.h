#ifndef NANOSOFT_DOUBLEPOOL_H
#define NANOSOFT_DOUBLEPOOL_H

#include <sys/types.h>
#include <nanosoft/simplepool.h>

namespace nanosoft
{
	/**
	* Двойной пул памяти
	*
	* Двойной пул инкапсулирует в себе два простых пула временных
	* объектов: активный и временный. Временный подпул используется
	* для выделения памяти под временные объекты, а активный
	* для выделения памяти под результирующие объекты, которые
	* нужно вернуть вызывающей стороне или хранить постоянно.
	*/
	class DoublePool
	{
	private:
		/**
		* Активный пул
		*/
		SimplePool *active;
		
		/**
		* Временный пул
		*/
		SimplePool *temp;
		
		/**
		* Обменять пулы местами
		*/
		void swap();
		
	public:
		/**
		* Конструктор двойного пула
		*
		* Параметры size и stack_len определяют размер пула
		* и размер внутреннего стека контекстов. Для нормальной
		* работы пула предполагается, что разработчик или
		* администратор приложения в состоянии оценить требуемые
		* размеры. В случае превышения данных характеристик
		* соответствующие функции выводят в stderr сообщение об
		* ошибке и генерируют исключение.
		*
		* @param name название пула для вывода диагностических сообщений
		* @param size размер пула памяти
		* @param stack_len размер стека контекстов (максимальное число
		*   вложенных контекстов)
		*/
		DoublePool(const char *name, size_t size, size_t stack_len);
		
		/**
		* Деструктор двойного пула
		*/
		~DoublePool();
		
		/**
		* Выделить память из активного пула
		*
		* Если память выделить не удается, то данная функция выводит
		* сообщение об ошибке в stderr и генерирует исключение.
		*
		* @param size требуемый размер блока
		* @return указатель на выделеный блок
		*/
		void * alloc(size_t size);
		
		/**
		* Выделить память из пула временных объектов
		*
		* Если память выделить не удается, то данная функция выводит
		* сообщение об ошибке в stderr и генерирует исключение.
		*
		* @param size требуемый размер блока
		* @return указатель на выделеный блок
		*/
		void * tempAlloc(size_t size);
		
		/**
		* Открыть новый контекст
		*
		* Данная функция запоминает занятый объем, чтобы потом
		* восстановить его методом leave(). Информация сохраняется
		* во внутреннем стеке. Если стек переполнен, то в stderr
		* выводиться сообщение об ошибке и генерируется исключение.
		*/
		void enter();
		
		/**
		* Закрыть контекст
		*
		* Данная функция закрывает контекст и "освобождает"
		* всю память которая была запрошена внутри этого
		* контекста.
		*
		* Если внутренный стек контекстов пуст, то в stderr
		* выводиться сообщение об ошибке и генерируется исключение.
		*/
		void leave();
		
		/**
		* Вернуть название пула
		* @return название пула
		*/
		const char * getPoolName();
		
		/**
		* Вернуть объем свободной памяти
		* @return размер свободной память
		*/
		size_t getFreeSize();
		
		/**
		* Вернуть размер выделенной памяти
		* @return размер выделенной памяти
		*/
		size_t getBusySize();
		
		/**
		* Вернуть глубину контекста
		*/
		size_t getStackDepth();
		
		/**
		* Вернуть максимальный зафиксированный размер занятой памяти
		*
		* Данная функция может использоваться для статистики и эмпирических
		* оценок потребностей в памяти.
		*
		* @return максимальный зафиксированный размер занятой памяти
		*/
		size_t getPeakMemory();
		
		/**
		* Вернуть максимальную зафиксированную глубину стека
		*
		* Данная функция может использоваться для статистики и эмпирической
		* оценки необходимой глубины стека.
		*
		* @return максимальная зафиксированная глубина стека
		*/
		size_t getPeakDepth();
	};
}

#endif // NANOSOFT_DOUBLEPOOL_H
